import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { connectToDatabase } from '@/lib/db';
import { withAuth } from '@/lib/auth';
import { validateData, handleApiError } from '@/lib/api-utils';
import { ServiceRequest, MaintenanceRecord, Vehicle } from '@/models';

// Define type for the JWT payload
interface JwtPayload {
  userId: string;
  email: string;
  role: string;
  iat?: number;
  exp?: number;
}

// Validation schema for updating service requests
const updateServiceRequestSchema = z.object({
  serviceType: z.string().min(1).optional(),
  description: z.string().min(1).optional(),
  status: z.enum(['pending', 'accepted', 'in-progress', 'completed', 'cancelled']).optional(),
  appointmentDate: z.string().optional().transform(val => val ? new Date(val) : undefined),
  estimatedCompletionDate: z.string().optional().transform(val => val ? new Date(val) : undefined),
  actualCompletionDate: z.string().optional().transform(val => val ? new Date(val) : undefined),
  location: z.object({
    address: z.string().min(1),
    city: z.string().min(1),
    state: z.string().min(1),
    postalCode: z.string().min(1),
    coordinates: z.object({
      latitude: z.number(),
      longitude: z.number(),
    }).optional(),
  }).optional(),
  estimatedCost: z.number().min(0).optional(),
  finalCost: z.number().min(0).optional(),
  images: z.array(z.string()).optional(),
});

// Validation schema for completing service requests
const completeServiceRequestSchema = z.object({
  finalCost: z.number().min(0, 'Final cost is required'),
  serviceDate: z.string().transform(val => new Date(val)),
  mileage: z.number().optional(),
  notes: z.string().optional(),
  receipts: z.array(z.string()).optional(),
});

/**
 * Helper function to extract the service request ID from the URL
 */
function extractServiceRequestId(req: NextRequest): string {
  const path = req.nextUrl.pathname;
  return path.split('/').pop() || '';
}

/**
 * GET: Get a specific service request
 */
async function getServiceRequest(req: NextRequest, user?: JwtPayload) {
  try {
    await connectToDatabase();
    const serviceRequestId = extractServiceRequestId(req);
    
    // Find service request
    const serviceRequest = await ServiceRequest.findById(serviceRequestId)
      .populate('vehicleId', 'make model year registrationNumber')
      .populate('ownerId', 'fullName email')
      .populate('repairerId', 'fullName email businessInfo')
      .populate('maintenanceRecordId');
    
    if (!serviceRequest) {
      return NextResponse.json(
        { error: 'Service request not found' },
        { status: 404 }
      );
    }
    
    // Check access permissions
    if (!user) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }
    
    const hasAccess = 
      user.role === 'ADMIN' || 
      serviceRequest.ownerId._id.toString() === user.userId || 
      (serviceRequest.repairerId && serviceRequest.repairerId._id.toString() === user.userId);
    
    if (!hasAccess) {
      return NextResponse.json(
        { error: 'Access denied' },
        { status: 403 }
      );
    }
    
    return NextResponse.json(serviceRequest);
  } catch (error) {
    return handleApiError(error);
  }
}

/**
 * PUT: Update a service request
 */
async function updateServiceRequest(req: NextRequest, user?: JwtPayload) {
  try {
    await connectToDatabase();
    const serviceRequestId = extractServiceRequestId(req);
    
    // Find service request
    const serviceRequest = await ServiceRequest.findById(serviceRequestId);
    
    if (!serviceRequest) {
      return NextResponse.json(
        { error: 'Service request not found' },
        { status: 404 }
      );
    }
    
    // Validate request data
    const body = await validateData(req, updateServiceRequestSchema);
    
    // Check permissions
    if (!user) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }
    
    // Admin can update anything
    if (user.role === 'ADMIN') {
      // Allow full updates
    } 
    // Vehicle owner can update their own service requests
    else if (serviceRequest.ownerId.toString() === user.userId) {
      // Only allow updating status to cancelled
      if (body.status && body.status !== 'cancelled') {
        delete body.status;
      }
    } 
    // Repairer can update service requests they're assigned to
    else if (user.role === 'REPAIRER') {
      // Check if this repairer is assigned to this service request
      // or if they're accepting a new one (and none is assigned yet)
      const canUpdate = 
        (serviceRequest.repairerId?.toString() === user.userId) ||
        (body.status === 'accepted' && !serviceRequest.repairerId);
      
      if (!canUpdate) {
        return NextResponse.json(
          { error: 'You are not authorized to update this service request' },
          { status: 403 }
        );
      }
      
      // If repairer is accepting the request, assign them
      if (body.status === 'accepted' && !serviceRequest.repairerId) {
        body.repairerId = user.userId;
      }
    } else {
      return NextResponse.json(
        { error: 'You are not authorized to update this service request' },
        { status: 403 }
      );
    }
    
    // If updating location with coordinates
    if (body.location?.coordinates) {
      // GeoJSON format for MongoDB
      body.location.coordinates = {
        latitude: body.location.coordinates.latitude,
        longitude: body.location.coordinates.longitude,
      };
    }
    
    // Update service request
    const updatedServiceRequest = await ServiceRequest.findByIdAndUpdate(
      serviceRequestId,
      { $set: body },
      { new: true, runValidators: true }
    );
    
    return NextResponse.json(updatedServiceRequest);
  } catch (error) {
    return handleApiError(error);
  }
}

/**
 * POST: Complete a service request and create maintenance record
 */
async function completeServiceRequest(req: NextRequest, user?: JwtPayload) {
  try {
    await connectToDatabase();
    const serviceRequestId = extractServiceRequestId(req);
    
    // Find service request
    const serviceRequest = await ServiceRequest.findById(serviceRequestId)
      .populate('vehicleId');
    
    if (!serviceRequest) {
      return NextResponse.json(
        { error: 'Service request not found' },
        { status: 404 }
      );
    }
    
    // Check if service request is in progress
    if (serviceRequest.status !== 'in-progress') {
      return NextResponse.json(
        { error: 'Only in-progress service requests can be completed' },
        { status: 400 }
      );
    }
    
    // Validate request data
    const body = await validateData(req, completeServiceRequestSchema);
    
    // Check permissions - only assigned repairer can complete
    if (!user) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }
    
    if (user.role !== 'REPAIRER' ||
        serviceRequest.repairerId?.toString() !== user.userId) {
      return NextResponse.json(
        { error: 'Only the assigned repairer can complete this service request' },
        { status: 403 }
      );
    }
    
    // Create maintenance record
    const maintenanceRecord = await MaintenanceRecord.create({
      vehicleId: serviceRequest.vehicleId._id,
      serviceDate: body.serviceDate,
      serviceType: serviceRequest.serviceType,
      description: serviceRequest.description,
      mileage: body.mileage,
      cost: body.finalCost,
      workshopId: serviceRequest.repairerId,
      serviceRequestId: serviceRequest._id,
      attachments: body.receipts,
      createdAt: new Date()
    });
    
    // Update service request
    const updatedServiceRequest = await ServiceRequest.findByIdAndUpdate(
      serviceRequestId,
      { 
        $set: { 
          status: 'completed',
          finalCost: body.finalCost,
          actualCompletionDate: new Date(),
          maintenanceRecordId: maintenanceRecord._id,
          notes: body.notes,
        } 
      },
      { new: true }
    );
    
    // Update vehicle's maintenance history
    await Vehicle.findByIdAndUpdate(
      serviceRequest.vehicleId._id,
      { $push: { maintenanceHistory: maintenanceRecord._id } }
    );
    
    return NextResponse.json({
      serviceRequest: updatedServiceRequest,
      maintenanceRecord
    });
  } catch (error) {
    return handleApiError(error);
  }
}

/**
 * DELETE: Cancel a service request
 */
async function cancelServiceRequest(req: NextRequest, user?: JwtPayload) {
  try {
    await connectToDatabase();
    const serviceRequestId = extractServiceRequestId(req);
    
    // Find service request
    const serviceRequest = await ServiceRequest.findById(serviceRequestId);
    
    if (!serviceRequest) {
      return NextResponse.json(
        { error: 'Service request not found' },
        { status: 404 }
      );
    }
    
    // Check if service request can be cancelled
    if (['completed', 'cancelled'].includes(serviceRequest.status)) {
      return NextResponse.json(
        { error: `Service request is already ${serviceRequest.status}` },
        { status: 400 }
      );
    }
    
    // Check permissions
    if (!user) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }
    
    const hasAccess = 
      user.role === 'ADMIN' ||
      serviceRequest.ownerId.toString() === user.userId ||
      (serviceRequest.repairerId?.toString() === user.userId && user.role === 'REPAIRER');
    
    if (!hasAccess) {
      return NextResponse.json(
        { error: 'You are not authorized to cancel this service request' },
        { status: 403 }
      );
    }
    
    // Cancel service request
    const updatedServiceRequest = await ServiceRequest.findByIdAndUpdate(
      serviceRequestId,
      { $set: { status: 'cancelled' } },
      { new: true }
    );
    
    return NextResponse.json(updatedServiceRequest);
  } catch (error) {
    return handleApiError(error);
  }
}

// Export handlers with authentication middleware
export const GET = withAuth(getServiceRequest, { requiresAuth: true });
export const PUT = withAuth(updateServiceRequest, { requiresAuth: true });
export const POST = withAuth(completeServiceRequest, {
  requiresAuth: true,
  allowedRoles: ['REPAIRER']
});
export const DELETE = withAuth(cancelServiceRequest, { requiresAuth: true });